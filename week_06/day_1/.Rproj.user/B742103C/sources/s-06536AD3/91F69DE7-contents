---
title: "Probability"
subtitle: "week 6 - day 1"
output: html_notebook
---

# Packages

```{r}


library(tidyverse)
```

# The prob package

```{r}
library(prob)
```

__roll die/toss coin__

```{r}
rolldie(2)
tosscoin(4)
```

```{r}

s_two_dice <- rolldie(2)

```

_summarise total sample space for two die_

```{r}
s_two_dice %>% 
  summarise(size_of_sample = n())
```

_find events where two die sum to 7_

```{r}
s_two_dice %>% 
  filter(X1 + X2 == 7)
```

```{r}
s_two_dice %>% 
  mutate(total = X1 + X2)
```

# Counting rules

A counting rule is a way to figure out the number of outcomes in a probability
problem.

## single step experiments

Only one step in the experiment, i.e tossing a coin, rolling a die. 

Average of a boolean vector = probability of an event

__find probability by dividing rows__

```{r}
prob_total_seven <- nrow(total_seven) / nrow(s)
```

## multi step experiments

to compute the size of sample space from a multi step experiment, find the 
product of the sizes in each of the steps.

```{r}

(1/2) * (1/6)

s_die <- rolldie(1)

s_coin <- tosscoin(1)

s_total <- merge(s_coin, s_die)

event <- s_total %>% 
  filter(toss1 == "H" & X1 == 6)

p_event <- nrow(event)/nrow(s_total)

```

# Permutations

```{r}
library(gtools)
permutations(7, 4)


# create vector of choices contains ten employees, n = 10. 
employees <- c("Alice", "Bob", "Carole", "David", "Elaine", "Fred", "Gabra", "Hua", "Inigo", "Hugo")

# Choose three at a time, r = 3
# Don't replace an employee once chosen: repeats.allowed = FALSE
seniors <- as_tibble(permutations(n = 10, r = 3, v = employees, repeats.allowed = FALSE))

# rename the variables in seniors to something better
seniors <- seniors %>%
  rename(
    CEO = V1,
    CTO = V2,
    COO = V3
  )

# let's see what the seniors matrix looks like
seniors
```

# Combinations

```{r}
num_draws <- choose(50, 6)
```

# Combining Events

__Complement__

if p = 0.3, its complement is 0.7. Should add to 1.0

__AND and OR__

To compute the probability of two independent events both occurring, multiply
both probabilities together. (AND)

To compute the prob of either two events occurring, add both probs together. (OR)

__Mutually Exclusive__

Two (or more) events that cannot happen simultaneously.

```{r}
s_four_coins <- tosscoin(4) %>% 
  mutate(row = row_number())
```

```{r}
s_four_coins <- s_four_coins %>% 
  mutate(num_heads = rowSums(. == "H"))

s_at_least_two_heads <- s_four_coins %>% 
  dplyr::filter(num_heads >= 2)   # this is since we need dplyr filter, not filter in prob package.

# prob of two or more heads
nrow(s_at_least_two_heads)/nrow(s_four_coins)
```

# AND combinations

__compound event__

Roll single dice

_event A:_ one of { 1, 2, 3, 4 }
_event B:_ one of { 3, 4, 5, 6 }

```{r}

s_four_coins <- s_four_coins %>% 
  mutate(num_tails = rowSums(. == "T"))

combined_prob <- s_four_coins %>% 
  dplyr::filter(num_heads >= 1 & num_tails >= 1)

nrow(combined_prob)/nrow(s_four_coins)

```

# check addition formula for intersect

$$prob(A∪B)=prob(A)+prob(B)−prob(A∩B)$$
```{r}

total <- rolldie(2)

first_die_even <- rolldie(2) %>% 
  filter(X1 %% 2 == 0)

prob_first_die_even <- nrow(first_die_even)/nrow(total)

second_die_5 <- rolldie(2) %>% 
  filter(X2 == 5)

prob_second_die_5 <- nrow(second_die_5)/nrow(total)

both <- rolldie(2) %>% 
  filter(X1 %% 2 == 0 & X2 == 5)

prob_both <- nrow(both)/nrow(total)

# first total 0.583333
prob_first_die_even + prob_second_die_5 - prob_both

# check to match below

prob_to_check <- rolldie(2) %>% 
  filter(X1 %% 2 == 0 | X2 == 5)

# 0.5833333
nrow(prob_to_check)/nrow(total)

```

# Conditional probability

Prob ( 5 | odd ) = 1 in 3

The conditioning event filters down the space of outcomes we have to consider.

# Dependant and Independant events 

$$\cup$$ = logical or

$$prob( A | B ) = prob(A)$$ == proves independence  since B had no effect. 

```{r}
library(here)
cb_data <- read_csv(here("data/colour_blindness.csv"))
library(janitor)
```

```{r}
cb_data %>% 
  tabyl(bio_sex, cblind) %>%
  #adorn_totals(where = c("row", "col")) %>% 
  adorn_percentages(denominator = ("all")) %>% # could specify row and col too.
  adorn_title(col_name = "Is colourblind") 
  
```

```{r}

cb_data %>% 
  tabyl(bio_sex, cblind) %>%
  adorn_totals(where = c("row", "col")) %>% 
  adorn_percentages(denominator = ("all")) %>% # could specify row and col too.
  adorn_title(col_name = "Is colourblind") 


```

```{r}

male_prob <- cb_data %>%
  summarise(prob = sum(bio_sex == "male") / n())
male_prob

prob_cb <- cb_data %>%
  summarise(prob = sum(cblind) / n())
prob_cb

prob_not_cb <- cb_data %>%
  summarise(prob = sum(!cblind) / n())
prob_not_cb

```

```{r}
prob_female_cb <- cb_data %>%
  filter(bio_sex == "female", cblind == TRUE) %>%
  summarise(prob = n() / nrow(cb_data))

prob_female <- cb_data %>%
  summarise(prob = sum(bio_sex == "female") / n())

prob_female * prob_cb
prob_female
```


# conditional probability

What is the prob of a person being colour blind given that we know they are 
female?

What proportion of female people are colour blind?

```{r}
prob_cb_given_female <- cb_data %>%
  filter(bio_sex == "female") %>%
  summarise(prob = sum(cblind) / n())

prob_cb_given_female
```

```{r}
0.042/0.6
```

```{r}
prob_cb_given_male <- cb_data %>%
  filter(bio_sex == "male") %>%
  summarise(prob = sum(cblind) / n())

prob_cb_given_male


```

